
//                         //  shader pipeline + (tes evaluation shader + tes control from cpu (need make tes con shader))

#version 460 core

// layout (triangles, equal_spacing) in;
layout (quads, equal_spacing) in;

layout (location = 0) in In { vec3 color; } inD[];
layout (location = 0) out Out { vec3 color; } outD;


void main()
{
    float u = gl_TessCoord.x;
    float v = gl_TessCoord.y;

    vec4 bl = gl_in[0].gl_Position;
    vec4 br = gl_in[1].gl_Position;
    vec4 tr = gl_in[2].gl_Position;
    vec4 tl = gl_in[3].gl_Position;

    vec4 leftPos = bl + v * (tl - bl);
    vec4 rightPos = br + v * (tr - br);
    gl_Position = leftPos + u * (rightPos - leftPos);
    
    vec3 uv0 = inD[0].color;
    vec3 uv1 = inD[1].color;
    vec3 uv2 = inD[2].color;
    vec3 uv3 = inD[3].color;
    
    vec3 leftUV = uv0 + v * (uv3 - uv0);
    vec3 rightUV = uv1 + v * (uv2 - uv1);
    outD.color = leftUV + u * (rightUV - leftUV);


    // //  triangle 2D interpolation
	// gl_Position = gl_TessCoord.x * gl_in [0].gl_Position + 
    //               gl_TessCoord.y * gl_in [1].gl_Position +
    //               gl_TessCoord.z * gl_in [2].gl_Position +
    // outD.color = gl_TessCoord.x * inD[0].color + gl_TessCoord.y * inD[1].color + gl_TessCoord.z * inD[2].color;

// vec2 Interpolate2D(vec2 v0, vec2 v1, vec2 v2)
// {
//     return vec2(gl_TessCoord.x) * v0 + vec2(gl_TessCoord.y) * v1 + vec2(gl_TessCoord.z) * v2;
// }
}